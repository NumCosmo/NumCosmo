---
title: "Benchmarking NumCosmo vs. CCL"
author: "Sandro Dias Pinto Vitenti"
date: "2025-02-09"
abstract: |
    This document shows the NumCosmo implementation of cosmology background functions and compares it to the CCL ones.

format:
  html:
    tbl-cap-location: margin
    fig-cap-location: margin
---

{{< include /_definitions.qmd >}}

## Introduction

This notebook explores the cosmological background functions implemented in the Core Cosmology Library (CCL) and NumCosmo, two frameworks for computing cosmological quantities. 
We aim to assess the consistency and accuracy of distance measures, such as comoving and luminosity distances, across these frameworks by comparing their outputs under identical physical parameters. 
To facilitate this analysis, we first establish a set of cosmological models with fixed and variable parameters, then define a function to compute and visualize the distances alongside their relative differences. 
The results are summarized in tables and plots below. 


```{python}
import sys
import numpy as np
import math
import matplotlib.pyplot as plt
from IPython.display import HTML, Markdown, display

# CCL
import pyccl
import pandas as pd

# NumCosmo
from numcosmo_py import Nc, Ncm
from numcosmo_py.ccl.nc_ccl import create_nc_obj, CCLParams, dsigmaM_dlnM
from numcosmo_py.plotting.tools import set_rc_params_article, format_time, latex_float
import numcosmo_py.cosmology as ncc
import numcosmo_py.ccl.comparison as nc_cmp

```

### Initializing NumCosmo

To begin, we configure NumCosmo and redirect its output to this notebook using the following code:

```{python}
Ncm.cfg_init()
Ncm.cfg_set_log_handler(lambda msg: sys.stdout.write(msg) and sys.stdout.flush())
set_rc_params_article(ncol=2, fontsize=12, use_tex=False)
```

### Initial Parameter Definitions

We initialize the cosmological parameters and model-specific variables used for distance comparisons in NumCosmo. 
Scalar parameters are fixed across all models, while arrays define variations in dark energy and neutrino properties for multiple scenarios.
First, we instantiate a CCL cosmology object using the predefined global parameters. 
Next, using the `numcosmo_py` function `create_nc_obj`, we generate a NumCosmo cosmology object initialized with the same parameters as the CCL model. 
Fixed scalars apply universally, while arrays ($\Omega_v$, $w_0$, $w_a$, $m_\nu$) represent different model configurations.

```{python}
# | code-fold: true

PARAMETERS_SET = [
    r"$\Lambda$CDM, flat",
    r"$\Lambda$CDM, flat, $1\nu$",
    r"XCDM, flat, $2\nu$",
    r"XCDM, spherical, $2\nu$",
    r"XCDM, hyperbolic, $2\nu$",
]
COLORS = plt.rcParams["axes.prop_cycle"].by_key()["color"][:5]


def setup_models(
    Omega_c: float = 0.25,  # Cold dark matter density
    Omega_b: float = 0.05,  # Baryonic matter density
    h: float = 0.7,  # Dimensionless Hubble constant
    sigma8: float = 0.9,  # Matter density contrast std. dev. (8 Mpc/h)
    n_s: float = 0.96,  # Scalar spectral index
    Neff: float = 3.046,  # Effective number of massless neutrinos
    high_precision: bool = False,  # Use high precision computations in CCL
):
    """Setup cosmological models."""
    Omega_v_vals = np.array([0.7, 0.7, 0.7, 0.65, 0.75])  # Dark energy density
    w0_vals = np.array([-1.0, -1.0, -0.9, -0.9, -0.9])  # DE equation of state w0
    wa_vals = np.array([0.0, 0.0, 0.1, 0.1, 0.1])  # DE equation of state wa

    # Neutrino masses (eV) for each model: [m1, m2, m3]
    mnu = np.array(
        [
            [0.0, 0.0, 0.0],
            [0.04, 0.0, 0.0],
            [0.05, 0.01, 0.0],
            [0.03, 0.02, 0.0],
            [0.03, 0.02, 0.0],
        ]
    )
    Omega_k_vals = [
        float(1.0 - Omega_c - Omega_b - Omega_v) for Omega_v in Omega_v_vals
    ]

    parameters = [
        ["$\\Omega_c$", "Cold Dark Matter Density", Omega_c],
        ["$\\Omega_b$", "Baryonic Matter Density", Omega_b],
        ["$\\Omega_v$", "Dark Energy Density", Omega_v_vals],
        ["$\\Omega_k$", "Curvature Density", [f"{v:.3f}" for v in Omega_k_vals]],
        ["$h$", "Hubble Constant (dimensionless)", h],
        ["$n_s$", "Scalar Spectral Index", n_s],
        ["$N_\\mathrm{eff}$", "Effective Nº of Massless Neutrinos", Neff],
        ["$\\sigma_8$", "Matter Density Contrast Std. Dev. (8 Mpc/h)", sigma8],
        ["$w_0$", "DE Equation of State Parameter", w0_vals],
        ["$w_a$", "DE Equation of State Parameter", wa_vals],
        ["$m_\\nu$", "Neutrino Masses (eV)", [f"{m.tolist()}" for m in mnu]],
    ]
    models = []
    if high_precision:
        CCLParams.set_high_prec_params()

    for Omega_v, Omega_k, w0, wa, m in zip(
        Omega_v_vals, Omega_k_vals, w0_vals, wa_vals, mnu
    ):
        ccl_cosmo = pyccl.Cosmology(
            Omega_c=Omega_c,
            Omega_b=Omega_b,
            Neff=Neff,
            h=h,
            sigma8=sigma8,
            n_s=n_s,
            Omega_k=Omega_k,
            w0=w0,
            wa=wa,
            m_nu=m,
            transfer_function="eisenstein_hu",
        )
        cosmology = create_nc_obj(ccl_cosmo)
        models.append({"CCL": ccl_cosmo, "NC": cosmology})

    return parameters, models


parameters, models = setup_models(high_precision=False)
z = np.linspace(0.01, 15.0, 10000)

```

### Parameter Overview

The table below summarizes the parameters. There are five parameters sets.

```{python}
# | label: tbl-ccl-vs-nc-params
# | tbl-cap: Used cosmological parameters in CCL and NumCosmo
# | tbl-colwidths: [10, 30, 60]
# | code-fold: true

# Create DataFrame
df = pd.DataFrame(parameters, columns=["Symbol", "Description", "Value"])
display(Markdown(df.to_markdown(index=False, colalign=["left"] * len(df.columns))))
```

## Cosmology Parameters  

The following function compares the total mass density (baryonic + cold dark matter + massive neutrinos), the total mass density parameter, and the normalized Hubble function. 
Below, we present the results for all sets of parameters.

Note that in CCL, the total matter density parameter is defined as the sum of the matter density parameter and the massive neutrino density parameter. 
In contrast, NumCosmo defines it as the sum of the matter density parameter and the fraction of the massive neutrino density parameter that is non-relativistic at a given redshift. 
For consistency, we compute $\Omega_m$ using the CCL prescription.

```{python}

parameter_funcs = [
    nc_cmp.compare_Omega_m,
    nc_cmp.compare_Omega_g,
    nc_cmp.compare_Omega_nu,
    nc_cmp.compare_Omega_mnu,
]

parameter_comparisons: list[list[nc_cmp.CompareFunc1d]] = [
    [func(m["CCL"], m["NC"], z, model=name) for m, name in zip(models, PARAMETERS_SET)]
    for func in parameter_funcs
]

```

```{python}
# | label: fig-ccl-vs-nc-params-set0
# | fig-cap:
# |   - "Total matter density parameter"
# |   - "Radiation density parameter"
# |   - "Massless neutrino density parameter"
# |   - "Massive neutrino density parameter"
# | fig-cap-location: top
# | layout-ncol: 2
# | code-fold: true

for parameter_comparison in parameter_comparisons:
    fig, axs = plt.subplots(2, sharex=True)
    fig.subplots_adjust(hspace=0)

    for p, c in zip(parameter_comparison, COLORS):
        p.plot(axs=axs, color=c)

plt.show()
plt.close()
```

The following table summarizes the results for all sets.
```{python}
# | label: tbl-ccl-vs-nc-params-table
# | tbl-cap: Cosmological parameters computed using CCL and NumCosmo
# | tbl-colwidths: [15, 5, 20, 20, 20, 20]
# | code-fold: true

table = []

for parameter_comparison in parameter_comparisons:
    for p in parameter_comparison:
        table.append(p.summary_row())

df = pd.DataFrame(table, columns=nc_cmp.CompareFunc1d.table_header())

display(Markdown(df.to_markdown(index=False, colalign=["left"] * len(df.columns))))

```

## Distance

We define a function to compare cosmological distances calculated by the CCL and NumCosmo frameworks. 
The function then evaluates and compares the cosmological distances implemented in both libraries. 
Expand the cell below to view the code.

```{python}

distance_funcs = [
    nc_cmp.compare_Hubble,
    nc_cmp.compare_distance_comoving,
    nc_cmp.compare_distance_transverse,
    nc_cmp.compare_distance_angular_diameter,
    nc_cmp.compare_distance_luminosity,
    nc_cmp.compare_distance_modulus,
    nc_cmp.compare_distance_lookback_time,
    nc_cmp.compare_distance_comoving_volume,
]

distance_comparisons: list[list[nc_cmp.CompareFunc1d]] = [
    [func(m["CCL"], m["NC"], z, model=name) for m, name in zip(models, PARAMETERS_SET)]
    for func in distance_funcs
]

```

We plot the distance comparisons for all parameter sets.

```{python}
# | layout-ncol: 2
# | label: fig-ccl-vs-nc-distances-set0
# | fig-cap:
# |   - "Normalized Hubble Function"
# |   - "Comoving radial distance"
# |   - "Comoving transverse distance"
# |   - "Angular diameter distance"
# |   - "Luminosity distance"
# |   - "Distance modulus"
# |   - "Lookback time"
# |   - "Comoving volume element"
# | fig-cap-location: top
# | code-fold: true

for distance_comparison in distance_comparisons:
    fig, axs = plt.subplots(2, sharex=True)
    fig.subplots_adjust(hspace=0)

    for d, c in zip(distance_comparison, COLORS):
        d.plot(axs=axs, color=c)

plt.show()
plt.close()

```

Again a table summarizes the results for all parameter sets.

```{python}
# | label: tbl-ccl-vs-nc-distances-table-set0
# | tbl-cap: Cosmological distances computed using CCL and NumCosmo
# | tbl-colwidths: [15, 20, 5, 15, 15, 15, 15]
# | code-fold: true

table = []

for distance_comparison in distance_comparisons:
    for d in distance_comparison:
        table.append(d.summary_row())

df = pd.DataFrame(table, columns=nc_cmp.CompareFunc1d.table_header())

display(Markdown(df.to_markdown(index=False, colalign=["left"] * len(df.columns))))

```

### Time Comparison

We compare the time spent on calculating the cosmological distances. 
First, it is necessary to create again the cosmology used in the function, then we use "timeit" to estimate the mean time intervals it takes for each library to perform the calculations. 
Below we show the comparison using the first set of parameters.

```{python}
# | label: tbl-ccl-vs-nc-times-set0
# | tbl-cap: Time to compute the cosmological distances
# | tbl-colwidths: [20, 20, 20, 20]
# | code-fold: true
def compute_distance_times(
    ccl_cosmo: pyccl.Cosmology, cosmology: ncc.Cosmology, z: np.ndarray
):
    cosmo = cosmology.cosmo
    dist = cosmology.dist

    a = 1.0 / (1.0 + z)
    z_vec = Ncm.Vector.new_array(z)
    D_vec = z_vec.dup()
    table = [
        ["Comoving Distance", "CCL"]
        + nc_cmp.compute_times(lambda: pyccl.comoving_radial_distance(ccl_cosmo, a)),
        ["Comoving Distance", "NumCosmo"]
        + nc_cmp.compute_times(lambda: dist.comoving_vector(cosmo, z_vec, D_vec)),
        ["Transverse Distance", "CCL"]
        + nc_cmp.compute_times(lambda: pyccl.comoving_angular_distance(ccl_cosmo, a)),
        ["Transverse Distance", "NumCosmo"]
        + nc_cmp.compute_times(lambda: dist.transverse_vector(cosmo, z_vec, D_vec)),
        ["Angular Diameter Distance", "CCL"]
        + nc_cmp.compute_times(lambda: pyccl.angular_diameter_distance(ccl_cosmo, a)),
        ["Angular Diameter Distance", "NumCosmo"]
        + nc_cmp.compute_times(
            lambda: dist.angular_diameter_vector(cosmo, z_vec, D_vec)
        ),
        ["Luminosity Distance", "CCL"]
        + nc_cmp.compute_times(lambda: pyccl.luminosity_distance(ccl_cosmo, a)),
        ["Luminosity Distance", "NumCosmo"]
        + nc_cmp.compute_times(lambda: dist.luminosity_vector(cosmo, z_vec, D_vec)),
        ["Distance Modulus", "CCL"]
        + nc_cmp.compute_times(lambda: pyccl.distance_modulus(ccl_cosmo, a)),
        ["Distance Modulus", "NumCosmo"]
        + nc_cmp.compute_times(lambda: dist.dmodulus_vector(cosmo, z_vec, D_vec)),
    ]
    columns = ["Distance", "Library", "Mean Time", "Standard Deviation"]
    df = pd.DataFrame(table, columns=columns)

    df["Mean Time"] = df["Mean Time"].apply(format_time)
    df["Standard Deviation"] = df["Standard Deviation"].apply(format_time)
    return df


df = compute_distance_times(models[0]["CCL"], models[0]["NC"], z)

display(Markdown(df.to_markdown(index=False, colalign=["left"] * len(df.columns))))
```

## Growth Factor  

The following function compares the growth factor and growth rate between the CCL and NumCosmo cosmologies.  

Since CCL defines \(\Omega_m\) differently from NumCosmo, the resulting growth factor and growth rate will also differ. In practice, CCL includes ultra-relativistic neutrinos in the matter density, leading to increasing deviations at higher redshifts when compared to NumCosmo. This effect can be observed by inspecting the first model, which does not include massive neutrinos and shows the best agreement between the two approaches.

```{python}

growth_funcs = [
    nc_cmp.compare_growth_factor,
    nc_cmp.compare_growth_rate,
]

growth_comparisons: list[list[nc_cmp.CompareFunc1d]] = [
    [func(m["CCL"], m["NC"], z, model=name) for m, name in zip(models, PARAMETERS_SET)]
    for func in growth_funcs
]    

```

Below we plot the growth comparisons for all parameter sets.

```{python}
# | label: fig-ccl-vs-nc-growth-sets
# | fig-cap-location: top
# | fig-cap:
# |   - "Growth Factor"
# |   - "Growth Rate"
# | layout-ncol: 2
# | code-fold: true

for growth_comparison in growth_comparisons:
    fig, axs = plt.subplots(2, sharex=True)
    fig.subplots_adjust(hspace=0)

    for p, c in zip(growth_comparison, COLORS):
        p.plot(axs=axs, color=c)

plt.show()
plt.close()
```

The following table summarizes the results for all sets.

```{python}
# | label: tbl-ccl-vs-nc-growth-sets
# | tbl-cap: Growth Factor and Growth Rate
# | tbl-colwidths: [20, 20, 20, 20]
# | code-fold: true

table = []

for growth_comparison in growth_comparisons:
    for d in growth_comparison:
        table.append(d.summary_row(convert_g=False))

df = pd.DataFrame(table, columns=nc_cmp.CompareFunc1d.table_header())
display(Markdown(df.to_markdown(index=False, colalign=["left"] * len(df.columns))))

```

## Scale Factor

The next function will compare the scale factor calculated from a comoving distance $\chi$ (in Mpc).

```{python}

chi = np.geomspace(1.0, 1.0e3, 1000)

compare_scale_factor: list[nc_cmp.CompareFunc1d] = [
    nc_cmp.compare_scale_factor(m["CCL"], m["NC"], chi, model=name)
    for m, name in zip(models, PARAMETERS_SET)
]    

```

Below we compare the scale factors for all parameter sets.

```{python}
# | label: fig-ccl-vs-nc-scale-factor-sets
# | fig-cap-location: top
# | fig-cap: Scale Factor
# | code-fold: true

fig, axs = plt.subplots(2, sharex=True)
fig.subplots_adjust(hspace=0)

for p, c in zip(compare_scale_factor, COLORS):
    p.plot(axs=axs, color=c)

plt.show()
plt.close()

```

The following table summarizes the results for all sets.

```{python}
# | label: tbl-ccl-vs-nc-scale-factor-sets
# | tbl-cap: Scale Factor
# | tbl-colwidths: [20, 20, 20, 20]
# | code-fold: true

table = []

for d in compare_scale_factor:
    table.append(d.summary_row())

df = pd.DataFrame(table, columns=nc_cmp.CompareFunc1d.table_header())

display(Markdown(df.to_markdown(index=False, colalign=["left"] * len(df.columns))))

```

## Critical Surface Mass Density

The next function will compare the critical surface mass density.

```{python}

zs = z = np.linspace(1.0, 5.0, 10000)
zl = 0.5

compare_sigmaC: list[nc_cmp.CompareFunc1d] = [
    nc_cmp.compare_Sigma_crit(m["CCL"], m["NC"], zs, zl, model=name)
    for m, name in zip(models, PARAMETERS_SET)
]

```

Below we compare the critical surface mass density for all parameter sets.

```{python}
# | label: fig-ccl-vs-nc-sigmaC-sets
# | fig-cap-location: top
# | fig-cap: Critical Surface Mass Density
# | code-fold: true

fig, axs = plt.subplots(2, sharex=True)
fig.subplots_adjust(hspace=0)

for p, c in zip(compare_sigmaC, COLORS):
    p.plot(axs=axs, color=c)

plt.show()
plt.close()

```

The following table summarizes the results for all sets.

```{python}
# | label: tbl-ccl-vs-nc-sigmaC-sets
# | tbl-cap: Critical Surface Mass Density
# | tbl-colwidths: [20, 20, 20, 20]
# | code-fold: true

table = []

for d in compare_sigmaC:
    table.append(d.summary_row())

df = pd.DataFrame(table, columns=nc_cmp.CompareFunc1d.table_header())

display(Markdown(df.to_markdown(index=False, colalign=["left"] * len(df.columns))))

```

### Summary

The table below show all estimated times and orders of the minimum and maximum relative differences for each function compared in this notebook. The CCL function for the unnormalized growth factor is not being compared, since NumCosmo does not have a specific function to compute it.

<table {style="border-style: solid;"}>
  <tr>
    <th>Function</th>
    <th>Runtime CCL</th>
    <th>Runtime NumCosmo</th>
    <th>Min. Rel. Diff. Order</th>
    <th>Max. Rel. Diff. Order</th>
    <tr>
  <tr>
    <td>Norm. Hubble Function</td>
    <td>(424 ± 11) μs</td>
    <td>(6.49 ± 0.97) ms</td>
    <td>1e-12</td>
      <td>1e-05</td>
  </tr>
  <tr>
      <td>Comoving Distance</td>
      <td>(288 ± 3) μs</td>
      <td>(6.72 ± 0.83) ms</td>
      <td>1e-12</td>
      <td>1e-08</td>
  </tr>
  <tr>
      <td>Transverse Comoving Distance</td>
      <td>(312 ± 2) μs</td>
      <td>(7.58 ± 0.14) ms</td>
      <td>1e-12</td>
      <td>1e-08</td>
  </tr>
  <tr>
      <td>Angular Diameter Distance</td>
      <td>(605 ± 3) μs</td>
      <td>(7.52 ± 0.03) ms</td>
      <td>1e-12</td>
      <td>1e-08</td>
  </tr>
  <tr>
      <td>Luminosity Distance</td>
      <td>(325 ± 2) μs</td>
      <td>(7.58 ± 0.16) ms</td>
      <td>1e-12</td>
      <td>1e-08</td>
  </tr>
  <tr>
      <td>Distance Modulus</td>
      <td>(576 ± 6) μs</td>
      <td>(9.29 ± 0.92) ms</td>
      <td>1e-13</td>
      <td>1e-08</td>
  </tr>
  <tr>
      <td>Lookbacktime</td>
      <td>(576 ± 6) μs</td>
      <td>(9.29 ± 0.92) ms</td>
      <td>1e-11</td>
      <td>1e-07</td>
  </tr>    
  <tr>
      <td>Comoving volume element</td>
      <td>(576 ± 6) μs</td>
      <td>(9.29 ± 0.92) ms</td>
      <td>1e-11</td>
      <td>1e-05</td>
  </tr>    
  <tr>
      <td>Growth Factor</td>
      <td>(300 ± 19) μs</td>
      <td>(8.45 ± 0.11) ms</td>
      <td>1e-13</td>
      <td>1e-08</td>
  </tr>
  <tr>
      <td>Growth Rate</td>
      <td>(299 ± 2) μs</td>
      <td>(16.7 ± 0.11) ms</td>
      <td>1e-10</td>
      <td>1e-08</td>
  </tr>
  <tr>
    <td>Matter Density Parameter</td>
    <td>(493 ± 7) μs</td>
     <td>(12.3 ± 0.1) ms</td>
     <td>1e-10</td>
      <td>1e-08</td>
  </tr>
  <tr>
    <td>Matter Density</td>
    <td>(909 ± 3) μs</td>
    <td>(10.8 ± 0.86) ms</td>
    <td>1e-16</td>
      <td>1e-15</td>
  </tr>
   <tr>
      <td>Scale Factor</td>
      <td>(36.8 ± 0.1) μs</td>
      <td>(800 ± 8.45) μs</td>
      <td>1e-13</td>
      <td>1e-08</td>
  </tr>
  <tr>
      <td>Sigma Critical</td>
      <td>(1.150 ± 0.003) ms</td>
      <td>(10.4 ± 0.81) ms</td>
      <td>1e-09</td>
      <td>1e-09</td>
  </tr>
</table>
