#!/usr/bin/env python3
#
# numcosmo
#
# Wed Feb 8 10:00:00 2023
# Copyright  2023  Sandro Dias Pinto Vitenti
# <vitenti@uel.br>
#
# numcosmo
# Copyright (C) 2023 Sandro Dias Pinto Vitenti <vitenti@uel.br>
#
# numcosmo is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# numcosmo is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.

""" NumCosmo script to perform different tasks.
"""

from typing import Optional, Annotated
from pathlib import Path
import typer

from numcosmo_py import Ncm
from numcosmo_py.external.cosmosis import (
    convert_likelihoods,
    create_numcosmo_mapping,
    LinearMatterPowerSpectrum,
    NonLinearMatterPowerSpectrum,
)
from numcosmo_py.sampling import (
    FitRunner,
    FitRunMessages,
    FitGradType,
    check_runner_algorithm,
)

app = typer.Typer(no_args_is_help=True)
app_run = typer.Typer(no_args_is_help=True)
app.add_typer(app_run, name="run")

Ncm.cfg_init()


@app.command(name="from-cosmosis")
def numcosmo_from_cosmosis(
    inifile: Annotated[Path, typer.Argument(help="Path to the Cosmosis ini file.")],
    *,
    outfile: Annotated[
        Optional[Path],
        typer.Option(
            help="Path to the output file, if not given,"
            " the input file name is used with the extension .yaml."
        ),
    ] = None,
    matter_ps: Annotated[
        LinearMatterPowerSpectrum,
        typer.Option(help="Matter power spectrum to use."),
    ] = LinearMatterPowerSpectrum.NONE.value,
    nonlin_matter_ps: Annotated[
        NonLinearMatterPowerSpectrum,
        typer.Option(help="Non-linear matter power spectrum to use."),
    ] = NonLinearMatterPowerSpectrum.NONE.value,
    distance_max_z: Annotated[
        float,
        typer.Option(help="Max distance to optimize distance computations", min=0.0),
    ] = 10.0,
):
    """Converts a Cosmosis ini file to a NumCosmo yaml file, containing
    the same information. The NumCosmo yaml file can be used to run the
    same likelihoods in NumCosmo.

    :param inifile: Path to the Cosmosis ini file.
    :param outfile: Path to the output file, if not given, the input file name
        is used with the extension .yaml.
    :param matter_ps: Matter power spectrum to use.
    :param nonlin_matter_ps: Non-linear matter power spectrum to use.
    :param distance_max_z: Max distance to optimize distance computations.
    """

    if outfile is None:
        outfile = Path(inifile.stem + ".yaml")

    mapping = create_numcosmo_mapping(
        matter_ps=matter_ps,
        nonlin_matter_ps=nonlin_matter_ps,
        distance_max_z=distance_max_z,
    )

    model_builders, mset, likelihood = convert_likelihoods(inifile, mapping=mapping)

    builders_file = outfile.with_suffix(".builders.yaml")

    experiment = Ncm.ObjDictStr.new()
    experiment.add("likelihood", likelihood)
    experiment.add("model-set", mset)

    ser = Ncm.Serialize.new(Ncm.SerializeOpt.CLEAN_DUP)
    ser.dict_str_to_yaml_file(model_builders, builders_file.absolute().as_posix())
    ser.dict_str_to_yaml_file(experiment, outfile.absolute().as_posix())


@app_run.command(name="fit")
def numcosmo_run_fit(
    experiment: Annotated[
        Path, typer.Argument(help="Path to the experiment file to fit.")
    ],
    *,
    runner: Annotated[
        FitRunner,
        typer.Option(
            help="Algorithm to use for the fit.",
            case_sensitive=False,
        ),
    ] = FitRunner.NLOPT.value,
    algorithm: Annotated[
        Optional[str],
        typer.Option(
            help="Algorithm to use for the fit.",
            case_sensitive=False,
        ),
    ] = None,
    grad_type: Annotated[
        FitGradType,
        typer.Option(
            help="Gradient type to use for the fit.",
            case_sensitive=False,
        ),
    ] = FitGradType.NUMDIFF_FORWARD.value,
    run_messages: Annotated[
        FitRunMessages,
        typer.Option(
            help="Verbosity level for the fit.",
            case_sensitive=False,
        ),
    ] = FitRunMessages.SIMPLE.value,
):
    """Computes the best fit of the model to the data."""
    ser = Ncm.Serialize.new(Ncm.SerializeOpt.CLEAN_DUP)

    builders_file = experiment.with_suffix(".builders.yaml")
    model_builders = ser.dict_str_from_yaml_file(builders_file.absolute().as_posix())

    for model_builder_name in model_builders.keys():
        model_builder = model_builders.get(model_builder_name)
        model_builder.create()

    experiment_objects = ser.dict_str_from_yaml_file(experiment.absolute().as_posix())

    if experiment_objects.peek("likelihood") is None:
        raise RuntimeError("No likelihood found in experiment file")

    likelihood: Ncm.Likelihood = experiment_objects.get("likelihood")

    if experiment_objects.peek("model-set") is None:
        raise RuntimeError("No model-set found in experiment file")

    mset = experiment_objects.get("model-set")

    check_runner_algorithm(runner, algorithm)

    fit = Ncm.Fit.factory(runner.genum, algorithm, likelihood, mset, grad_type.genum)

    fit.log_info()
    fit.run(run_messages.genum)


@app_run.command()
def mcmc():
    """Runs a MCMC chain."""
    typer.echo("Another command")


if __name__ == "__main__":
    app()
