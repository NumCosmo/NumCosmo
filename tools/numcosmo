#!/usr/bin/env python3
#
# numcosmo
#
# Wed Feb 8 10:00:00 2023
# Copyright  2023  Sandro Dias Pinto Vitenti
# <vitenti@uel.br>
#
# numcosmo
# Copyright (C) 2023 Sandro Dias Pinto Vitenti <vitenti@uel.br>
#
# numcosmo is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# numcosmo is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.

""" NumCosmo script to perform different tasks.
"""

from typing import Optional, Annotated, Tuple
from pathlib import Path
import typer

from numcosmo_py import Ncm
from numcosmo_py.external.cosmosis import (
    convert_likelihoods,
    create_numcosmo_mapping,
    LinearMatterPowerSpectrum,
    NonLinearMatterPowerSpectrum,
)
from numcosmo_py.sampling import (
    FitRunner,
    FitRunMessages,
    FitGradType,
    NcmFitLogger,
    set_ncm_console,
    check_runner_algorithm,
)

app = typer.Typer(no_args_is_help=True, help="NumCosmo command line interface.")
app_run = typer.Typer(no_args_is_help=True, help="Run different statistical analyses.")
app.add_typer(app_run, name="run")


@app.command(name="from-cosmosis")
def numcosmo_from_cosmosis(
    inifile: Annotated[Path, typer.Argument(help="Path to the Cosmosis ini file.")],
    *,
    outfile: Annotated[
        Optional[Path],
        typer.Option(
            help="Path to the output file, if not given,"
            " the input file name is used with the extension .yaml."
        ),
    ] = None,
    matter_ps: Annotated[
        LinearMatterPowerSpectrum,
        typer.Option(help="Matter power spectrum to use."),
    ] = LinearMatterPowerSpectrum.NONE.value,
    nonlin_matter_ps: Annotated[
        NonLinearMatterPowerSpectrum,
        typer.Option(help="Non-linear matter power spectrum to use."),
    ] = NonLinearMatterPowerSpectrum.NONE.value,
    distance_max_z: Annotated[
        float,
        typer.Option(help="Max distance to optimize distance computations", min=0.0),
    ] = 10.0,
):
    """Converts a Cosmosis ini file to a NumCosmo yaml file, containing
    the same information. The NumCosmo yaml file can be used to run the
    same likelihoods in NumCosmo.

    :param inifile: Path to the Cosmosis ini file.
    :param outfile: Path to the output file, if not given, the input file name
        is used with the extension .yaml.
    :param matter_ps: Matter power spectrum to use.
    :param nonlin_matter_ps: Non-linear matter power spectrum to use.
    :param distance_max_z: Max distance to optimize distance computations.
    """

    Ncm.cfg_init()

    if outfile is None:
        outfile = Path(inifile.stem + ".yaml")

    mapping = create_numcosmo_mapping(
        matter_ps=matter_ps,
        nonlin_matter_ps=nonlin_matter_ps,
        distance_max_z=distance_max_z,
    )

    model_builders, mset, likelihood = convert_likelihoods(inifile, mapping=mapping)

    builders_file = outfile.with_suffix(".builders.yaml")

    experiment = Ncm.ObjDictStr.new()
    experiment.add("likelihood", likelihood)
    experiment.add("model-set", mset)

    ser = Ncm.Serialize.new(Ncm.SerializeOpt.CLEAN_DUP)
    ser.dict_str_to_yaml_file(model_builders, builders_file.absolute().as_posix())
    ser.dict_str_to_yaml_file(experiment, outfile.absolute().as_posix())


@app_run.command(
    name="test", help="Loads the experiment file and computes the likelihood once."
)
def numcosmo_run_test(
    experiment: Annotated[
        Path, typer.Argument(help="Path to the experiment file to fit.")
    ],
) -> None:
    """Test command."""
    ser = Ncm.Serialize.new(Ncm.SerializeOpt.CLEAN_DUP)

    builders_file = experiment.with_suffix(".builders.yaml")
    model_builders = ser.dict_str_from_yaml_file(builders_file.absolute().as_posix())

    for model_builder_name in model_builders.keys():
        model_builder = model_builders.get(model_builder_name)
        model_builder.create()

    # We need to initialize NumCosmo after creating the model builders
    # this is necessary because when using MPI, the model builders
    # should be created in all processes before initializing NumCosmo.
    Ncm.cfg_init()
    set_ncm_console()

    experiment_objects = ser.dict_str_from_yaml_file(experiment.absolute().as_posix())

    if experiment_objects.peek("likelihood") is None:
        raise RuntimeError("No likelihood found in experiment file")

    likelihood: Ncm.Likelihood = experiment_objects.get("likelihood")

    if experiment_objects.peek("model-set") is None:
        raise RuntimeError("No model-set found in experiment file")

    mset: Ncm.MSet = experiment_objects.get("model-set")
    mset.param_set_all_ftype(Ncm.ParamType.FIXED)

    fit = Ncm.Fit.factory(
        FitRunner.GSL_MMS.genum,
        None,
        likelihood,
        mset,
        FitGradType.NUMDIFF_FORWARD.genum,
    )
    fit.log_info()
    fit.run(FitRunMessages.SIMPLE.genum)


@app_run.command(name="fit")
def numcosmo_run_fit(
    experiment: Annotated[
        Path, typer.Argument(help="Path to the experiment file to fit.")
    ],
    *,
    runner: Annotated[
        FitRunner,
        typer.Option(
            help="Algorithm to use for the fit.",
        ),
    ] = FitRunner.NLOPT.value,
    algorithm: Annotated[
        Optional[str],
        typer.Option(
            help="Algorithm to use for the fit.",
        ),
    ] = None,
    grad_type: Annotated[
        FitGradType,
        typer.Option(
            help="Gradient type to use for the fit.",
        ),
    ] = FitGradType.NUMDIFF_FORWARD.value,
    run_messages: Annotated[
        FitRunMessages,
        typer.Option(
            help="Verbosity level for the fit.",
        ),
    ] = FitRunMessages.SIMPLE.value,
    output: Annotated[
        Optional[Path],
        typer.Option(
            help="Path to the output file, if given, the best fit is written to"
            " this file, otherwise the best fit is not saved."
        ),
    ] = None,
    restart: Annotated[
        Optional[Tuple[float, float]],
        typer.Option(
            help=(
                "Restart the fit until the given the value of m2lnL varies less"
                " than the given tolerance (abstol, reltol)."
            ),
        ),
    ] = None,
    starting_point: Annotated[
        Optional[Path],
        typer.Option(
            help=(
                "Path to the file containing the starting point for the fit. "
                "The output of a previous fit can be used."
            ),
        ),
    ] = None,
) -> None:
    """Computes the best fit of the model to the data."""
    ser = Ncm.Serialize.new(Ncm.SerializeOpt.CLEAN_DUP)

    builders_file = experiment.with_suffix(".builders.yaml")
    model_builders = ser.dict_str_from_yaml_file(builders_file.absolute().as_posix())

    for model_builder_name in model_builders.keys():
        model_builder = model_builders.get(model_builder_name)
        model_builder.create()

    # We need to initialize NumCosmo after creating the model builders
    # this is necessary because when using MPI, the model builders
    # should be created in all processes before initializing NumCosmo.
    Ncm.cfg_init()
    console = set_ncm_console()

    experiment_objects = ser.dict_str_from_yaml_file(experiment.absolute().as_posix())

    if experiment_objects.peek("likelihood") is None:
        raise RuntimeError("No likelihood found in experiment file")

    likelihood: Ncm.Likelihood = experiment_objects.get("likelihood")

    if experiment_objects.peek("model-set") is None:
        raise RuntimeError("No model-set found in experiment file")

    mset: Ncm.MSet = experiment_objects.get("model-set")

    check_runner_algorithm(runner, algorithm)

    if starting_point is not None:
        if not starting_point.exists():
            raise RuntimeError(f"Starting point file {starting_point} not found.")
        ser.reset(False)
        saved_mset: Ncm.MSet = ser.from_yaml_file(starting_point.absolute().as_posix())
        assert isinstance(saved_mset, Ncm.MSet)
        if not mset.cmp(saved_mset, True):
            raise RuntimeError(
                f"Starting point file {starting_point} does not match experiment."
            )
        mset.param_set_mset(saved_mset)

    fit = Ncm.Fit.factory(runner.genum, algorithm, likelihood, mset, grad_type.genum)
    fit.log_info()

    fit_logger = NcmFitLogger(console)
    fit.set_logger(
        fit_logger.write_progress,
        fit_logger.update_progress,
        fit_logger.start_update,
        fit_logger.end_update,
    )

    if restart is None:
        fit.run(run_messages.genum)
    else:
        if restart[0] <= 0.0 and restart[1] <= 0.0:
            raise RuntimeError(f"Invalid tolerance for restart {restart}.")
        output_filename = None if output is None else output.absolute().as_posix()
        fit.run_restart(
            run_messages.genum, restart[0], restart[1], None, output_filename
        )

    if output is not None:
        ser.reset(False)
        ser.to_yaml_file(fit.peek_mset(), output.as_posix())


@app_run.command(name="fisher")
def numcosmo_run_fisher(
    experiment: Annotated[
        Path, typer.Argument(help="Path to the experiment file to fit.")
    ],
    *,
    starting_point: Annotated[
        Optional[Path],
        typer.Option(
            help=(
                "Path to the file containing the starting point for the fit. "
                "The output of a previous fit can be used."
            ),
        ),
    ] = None,
    output: Annotated[
        Optional[Path],
        typer.Option(
            help="Path to the output file, if given, the best fit is written to"
            " this file, otherwise the best fit is not saved."
        ),
    ] = None,
) -> None:
    """Computes the Fisher matrix."""
    ser = Ncm.Serialize.new(Ncm.SerializeOpt.CLEAN_DUP)

    builders_file = experiment.with_suffix(".builders.yaml")
    model_builders = ser.dict_str_from_yaml_file(builders_file.absolute().as_posix())

    for model_builder_name in model_builders.keys():
        model_builder = model_builders.get(model_builder_name)
        model_builder.create()

    # We need to initialize NumCosmo after creating the model builders
    # this is necessary because when using MPI, the model builders
    # should be created in all processes before initializing NumCosmo.
    Ncm.cfg_init()
    console = set_ncm_console()

    experiment_objects = ser.dict_str_from_yaml_file(experiment.absolute().as_posix())

    if experiment_objects.peek("likelihood") is None:
        raise RuntimeError("No likelihood found in experiment file")

    likelihood: Ncm.Likelihood = experiment_objects.get("likelihood")

    if experiment_objects.peek("model-set") is None:
        raise RuntimeError("No model-set found in experiment file")

    mset: Ncm.MSet = experiment_objects.get("model-set")

    fit = Ncm.Fit.factory(FitRunner.GSL_MMS.genum, None, likelihood, mset)
    fit.log_info()

    fit_logger = NcmFitLogger(console)
    fit.set_logger(
        fit_logger.write_progress,
        fit_logger.update_progress,
        fit_logger.start_update,
        fit_logger.end_update,
    )

    if output is not None:
        ser.reset(False)
        ser.to_yaml_file(fit.peek_mset(), output.as_posix())


@app_run.command()
def mcmc():
    """Runs a MCMC chain."""
    typer.echo("Another command")


if __name__ == "__main__":
    app()
