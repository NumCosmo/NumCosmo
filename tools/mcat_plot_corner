#!/usr/bin/env python3
#
# plot_corner.py
#
# Wed Feb 8 10:00:00 2023
# Copyright  2023  Sandro Dias Pinto Vitenti
# <vitenti@uel.br>
#
# plot_corner.py
# Copyright (C) 2023 Sandro Dias Pinto Vitenti <vitenti@uel.br>
#
# numcosmo is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# numcosmo is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.

"""NumCosmoPy corner plot utilities."""

import argparse
import numpy as np

import chainconsumer as cc
from chainconsumer import ChainConsumer
from numcosmo_py import Ncm
import pandas as pd

parser = argparse.ArgumentParser(description="Process mset catalogs")

parser.add_argument(
    "-C",
    "--catalog",
    metavar="file.fits",
    help="catalog fits file",
    action="append",
    required=True,
)

parser.add_argument(
    "-B", "--burnin", metavar="N", help="catalog burnin", type=int, action="append"
)

parser.add_argument(
    "--kde", help="whether to use kde interpolation", action="store_true"
)

parser.add_argument("--col", type=int, nargs="*", help="Columns to include")

parser.add_argument("--truth", type=float, nargs="*", help="Columns to include")

parser.add_argument(
    "--sigma",
    type=int,
    nargs="+",
    default=[1, 2],
    help="Sigmas to compute the confidence regions",
)

parser.add_argument("--out", default="corner.pdf", help="Output filename")

parser.add_argument("--mode", choices=["corner", "walks"], default="corner")

args = parser.parse_args()

Ncm.cfg_init()

c = ChainConsumer()

for cat in args.catalog:

    burnin = 0
    if args.burnin and (len(args.burnin) > 0):
        burnin = args.burnin.pop(0)

    print(f"# Adding {cat} with burnin {burnin}")

    mcat = Ncm.MSetCatalog.new_from_file_ro(cat, burnin)
    nwalkers = mcat.nchains()

    m2lnL = mcat.get_m2lnp_var()

    rows = np.array([mcat.peek_row(i).dup_array() for i in range(mcat.len())])
    params = ["$" + mcat.col_symb(i) + "$" for i in range(mcat.ncols())]
    param_names = [mcat.col_name(i) for i in range(mcat.ncols())]
    rows[:, m2lnL] = -0.5 * rows[:, m2lnL]

    if args.col:
        assert max(args.col) < mcat.ncols()
        indices = np.array(args.col)

        rows = rows[:, indices]
        params = [params[i] for i in indices]
        param_names = [param_names[i] for i in indices]

    chain_df = pd.DataFrame(data=rows, columns=param_names)
    chain = cc.Chain(
        samples=chain_df,
        posterior_column=mcat.col_name(m2lnL),
        name=cat.replace("_", "-"),
        walkers=nwalkers,
    )
    c.add_chain(chain)

plot_args = {}

if args.truth is not None:
    plot_args["truth"] = args.truth

if args.mode == "corner":
    fig = c.plotter.plot(**plot_args)
elif args.mode == "walks":
    fig = c.plotter.plot_walks(**plot_args, convolve=100)
else:
    assert False

fig.savefig(args.out, bbox_inches="tight")
